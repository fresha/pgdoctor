# Primary Key Type Validation

Validates that primary keys use `bigint` or `uuid` types to prevent sequence exhaustion and ensure sufficient growth capacity.

## Why This Matters

Integer (int4) primary keys create a ticking time bomb for growing tables:

**The crisis scenario:**
- Integer PKs max out at **2,147,483,647** (~2.1 billion)
- When limit is reached, **ALL INSERT operations fail immediately**
- No graceful degradation—service goes from working to completely broken
- Migration requires downtime (int4 → bigint requires table rewrite)
- Foreign key relationships compound the migration complexity

**Real-world impact**: A high-traffic events table with 1M inserts/day exhausts its int4 PK in 5.8 years. The emergency migration requires:
1. Planned downtime during off-peak hours (2-4 hour window)
2. Coordinating migration of ALL foreign key tables
3. Application deployment to handle new PK type
4. Risk of data corruption if FK migration isn't atomic

**Prevention cost**: 5 minutes (use bigint from day 1)
**Reactive fix cost**: 12-72 hours of planning + downtime + customer impact + team stress

## What This Check Does

This check identifies **ALL** tables using `int4` (integer) or `int2` (smallint) for primary keys, which violates architecture standards.

**Key information provided:**
- **Table and column identification**: Which tables have non-compliant PK types
- **Usage percentage**: Current capacity utilization (calculated from sequence value or estimated from row count)
- **Row count**: Table size for migration planning
- **Severity prioritization**: Urgency based on how close to exhaustion

**Important**: Every table flagged by this check is non-compliant. There is no "acceptable" int4/int2 PK—all must be migrated to bigint or UUID.

## Severity Thresholds

All tables with int4/int2 primary keys are flagged. Severity indicates migration urgency:

- **FAIL (≥50% capacity)**: Urgent migration required
  - Tables are approaching exhaustion
  - Migration complexity increases with size
  - Risk of emergency downtime if not addressed

- **WARN (<50% capacity)**: Migration needed, less urgent
  - Architectural violation must be fixed
  - Migrate proactively before reaching 50%
  - Easier migration when table is smaller

**Usage % calculation:**
- Uses actual sequence value when available (most accurate)
- Falls back to estimated row count vs type max value
- Always available (only NULL for empty tables)

## Architecture Rationale

From the Database Architecture Guidelines:

> **MUST:** Use `bigint` or `UUIDv7` for primary keys.
> - Rationale: Prevents sequence wraparound on tables that grow with traffic
> - Exception: Small lookup tables that don't grow with user activity

**Why bigint/UUID:**
1. **Capacity**: Bigint supports 9.2 quintillion values (effectively unlimited)
2. **Future-proof**: Never worry about exhaustion again
3. **Standard practice**: Industry standard for modern applications
4. **Foreign key safety**: Tables referencing this PK inherit the capacity

**When to use each:**
- **bigint**: Single-database systems, ordered IDs, smaller index size (8 bytes)
- **uuid/UUIDv7**: Distributed systems, multi-region, no coordination needed (16 bytes)

## How to Fix

### For `pk-types`

All tables with int4/int2 primary keys must be migrated to bigint or UUID.

**Simple migration (small tables <1M rows):**

```sql
BEGIN;
  -- Migrate column type (acquires AccessExclusiveLock, rewrites table)
  ALTER TABLE users ALTER COLUMN id TYPE bigint;

  -- Migrate sequence
  ALTER SEQUENCE users_id_seq AS bigint MAXVALUE 9223372036854775807;
COMMIT;

-- Restart connection pools to invalidate prepared statements
-- Restart connection pools to invalidate prepared statements
```

**Lock duration:** ~1ms per 1,000 rows (100K rows ≈ 100ms downtime)

For large tables (>1M rows), complex foreign key relationships, or zero-downtime requirements, see detailed migration strategies in the "Migration Guide" section below.

## Migration Guide

### For New Tables (5 minutes)

Always use bigint or UUID from the start:

```sql
-- Recommended: bigint with IDENTITY (SQL standard, ORM-compatible)
CREATE TABLE users (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT NOW()
);

-- Legacy: bigint with SERIAL (still works, avoid for new tables)
CREATE TABLE events (
  id bigserial PRIMARY KEY,  -- Creates bigint + sequence
  event_type text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT NOW()
);

-- Distributed systems: UUIDv7 (time-ordered for index locality)
CREATE TABLE logs (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  message text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT NOW()
);
```

> **Why `GENERATED BY DEFAULT` instead of `GENERATED ALWAYS`?**
> `GENERATED ALWAYS` rejects explicit ID values unless you use `OVERRIDING SYSTEM VALUE`,
> which breaks ActiveRecord fixtures, Ecto seed scripts, data migrations with preserved IDs,
> and any code path that sets an explicit ID. `GENERATED BY DEFAULT` provides the same
> sequence-backed auto-increment while remaining compatible with all ORMs and operational
> workflows. See [PostgreSQL docs: Identity Columns](https://www.postgresql.org/docs/17/sql-createtable.html).

> **Why IDENTITY over SERIAL for new tables?**
> IDENTITY is SQL:2003 standard, creates a first-class catalog relationship (not just a
> default + dependency), and forces you to specify the type explicitly (`bigint`), avoiding
> the `serial` = `int4` footgun. Existing SERIAL columns do not need migration.

### For Existing Tables

#### Simple Migration (Small Tables <1M rows, Can Tolerate Brief Lock)

**⚠️ CRITICAL:** This acquires an **EXCLUSIVE LOCK for entire migration duration**, blocking ALL reads and writes.

**Lock duration** (~1ms per 1,000 rows, table rewrite required):
- 100K rows ≈ 100ms downtime
- 1M rows ≈ 1 second downtime

```sql
BEGIN;

-- Migrates column type (acquires AccessExclusiveLock, rewrites entire table)
ALTER TABLE users ALTER COLUMN id TYPE bigint;

-- Migrate sequence
ALTER SEQUENCE users_id_seq AS bigint MAXVALUE 9223372036854775807;

COMMIT;

-- Restart connection pools to invalidate prepared statements
-- Restart connection pools to invalidate prepared statements
```

**Note:** During migration, table is offline for ALL operations (SELECT, INSERT, UPDATE, DELETE).

#### Complex Migrations

For large tables (>1M rows), tables with foreign keys, or zero-downtime requirements, see detailed guides:

**Internal documentation:**
- Migration strategies (new column swap, pg_repack)
- Foreign key discovery and atomic migration
- Zero-downtime approaches

For large tables or zero-downtime requirements, see detailed migration strategies in the PostgreSQL documentation.

### Foreign Key Considerations

**When migrating a PK, you MUST migrate ALL referencing FKs.**

Quick FK discovery:
```sql
-- Find all tables with FKs to users.id
SELECT
  conrelid::regclass AS referencing_table,
  conname AS fk_constraint,
  a.attname AS fk_column
FROM pg_constraint c
JOIN pg_attribute a ON a.attrelid = c.conrelid AND a.attnum = ANY(c.conkey)
WHERE confrelid = 'users'::regclass
  AND contype = 'f';
```

**FK Migration Checklist:**
- [ ] Identify all FK references with query above
- [ ] Test migration on staging environment
- [ ] Schedule maintenance window (or use zero-downtime strategy)
- [ ] Migrate PK and ALL FKs in same transaction (atomic)
- [ ] Restart connection pools after migration
- [ ] Verify inserts work on all tables
- [ ] Monitor for 24 hours

## Related Checks

Run these checks together for comprehensive capacity planning:

- **`sequence-health`** - Monitors sequences approaching exhaustion (run AFTER fixing PK types)
- **`uuid-types`** - Validates UUID storage efficiency

**Run all schema checks together:**
```bash
pgdoctor run --dsn "..." --only pk-types,uuid-types,sequence-health,toast-storage
```

## Common Questions

**Q: Our table has only 50K rows with int4 PK, do we need bigint?**
A: It depends on growth rate:
- **Static lookup table?** Probably fine with int4 (countries, currencies, payment methods)
- **User-generated content?** Migrate to bigint proactively (easier now than at 1M rows)
- **Growth >10K rows/day?** Migrate immediately (will hit limit in years, not decades)

**Q: Can we use UUID everywhere?**
A: UUIDs have trade-offs:
- ✅ No coordination needed (great for distributed systems, multi-region)
- ✅ No sequence exhaustion concerns
- ✅ Can generate client-side (offline scenarios)
- ❌ Larger indexes (16 bytes vs 8 bytes for bigint = 2x index size)
- ❌ Random ordering (worse for B-tree locality, more page splits)
- **Recommendation**: Use UUIDv7 (time-ordered) for better index performance

**Q: Will migration invalidate prepared statements?**
A: Yes. Type changes invalidate prepared statements in connection pools.
- **Action**: Restart connection pools after migration
- **Impact**: Brief connection churn, <5 seconds of 503 errors
- **Mitigation**: Use graceful restart if supported by your pool

**Q: What about composite primary keys?**
A: Same principle applies—each column should use bigint or UUID:
```sql
-- Before: Composite PK with int4
CREATE TABLE order_items (
  order_id integer,
  item_id integer,
  PRIMARY KEY (order_id, item_id)
);

-- After: Composite PK with bigint
CREATE TABLE order_items (
  order_id bigint,
  item_id bigint,
  PRIMARY KEY (order_id, item_id)
);
```

**Q: Can we just increase the sequence max without migrating column type?**
A: **NO.** The column type is the limiting factor, not the sequence:
- int4 column = max 2,147,483,647 (even if sequence is bigint)
- Sequence can be bigint, but inserts will fail when value exceeds int4 max
- **You MUST migrate the column type first**

**Q: What about SMALLINT and INT2?**
A: Even worse—smallint maxes at 32,767:
- **Immediate action required** if table has >10K rows
- Use same migration strategies as int4 → bigint
- Common in legacy Rails apps (old migrations defaulted to smallint for foreign keys)
