// Package main generates the checks.go file for pgdoctor CLI by discovering check packages.
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// checkDiscovery represents a discovered check package.
type checkDiscovery struct {
	PackageName string // e.g., "pg_version"
	ImportPath  string // e.g., "github.com/fresha/pgdoctor/checks/pg_version"
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Find repo root by looking for go.mod
	repoRoot, err := findRepoRoot()
	if err != nil {
		return fmt.Errorf("finding repo root: %w", err)
	}

	// Find all check packages
	checksDir := filepath.Join(repoRoot, "checks")
	checks, err := discoverChecks(checksDir)
	if err != nil {
		return fmt.Errorf("discovering checks: %w", err)
	}

	if len(checks) == 0 {
		return fmt.Errorf("no checks found in %s", checksDir)
	}

	// Generate checks.go in pgdoctor package root
	pkgOutputPath := filepath.Join(repoRoot, "checks.go")
	if err := generateChecksFile(checks, pkgOutputPath); err != nil {
		return fmt.Errorf("generating checks.go: %w", err)
	}

	_, _ = fmt.Fprintf(os.Stdout, "✓ Generated %s with %d checks\n", pkgOutputPath, len(checks))
	for _, check := range checks {
		_, _ = fmt.Fprintf(os.Stdout, "  • %s\n", check.PackageName)
	}

	return nil
}

// findRepoRoot finds the repository root by looking for go.mod.
func findRepoRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("could not find go.mod in any parent directory")
		}
		dir = parent
	}
}

// discoverChecks scans the checks directory for packages with Metadata() function.
func discoverChecks(checksDir string) ([]checkDiscovery, error) {
	var checks []checkDiscovery

	entries, err := os.ReadDir(checksDir)
	if err != nil {
		return nil, fmt.Errorf("reading checks directory: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		packageName := entry.Name()
		checkPath := filepath.Join(checksDir, packageName)

		// Check if this package has a Metadata() function
		hasMetadata, err := packageHasMetadata(checkPath)
		if err != nil {
			return nil, fmt.Errorf("checking %s: %w", packageName, err)
		}

		if !hasMetadata {
			continue
		}

		checks = append(checks, checkDiscovery{
			PackageName: packageName,
			ImportPath:  fmt.Sprintf("github.com/fresha/pgdoctor/checks/%s", packageName),
		})
	}

	// Sort by package name for deterministic output
	sort.Slice(checks, func(i, j int) bool {
		return checks[i].PackageName < checks[j].PackageName
	})

	return checks, nil
}

// packageHasMetadata checks if a package exports a Metadata() function.
func packageHasMetadata(pkgPath string) (bool, error) {
	fset := token.NewFileSet()

	// Parse all .go files in the package (excluding _test.go)
	pkgs, err := parser.ParseDir(fset, pkgPath, func(fi os.FileInfo) bool {
		return !strings.HasSuffix(fi.Name(), "_test.go") && strings.HasSuffix(fi.Name(), ".go")
	}, 0)
	if err != nil {
		return false, err
	}

	// Check each package (should only be one non-test package)
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			// Look for exported Metadata function
			for _, decl := range file.Decls {
				funcDecl, ok := decl.(*ast.FuncDecl)
				if !ok {
					continue
				}

				// Check if function is named "Metadata" and is exported
				if funcDecl.Name.Name == "Metadata" && funcDecl.Name.IsExported() {
					return true, nil
				}
			}
		}
	}

	return false, nil
}

// generateChecksFile generates the checks.go file with both metadata and checker functions.
func generateChecksFile(checks []checkDiscovery, outputPath string) error {
	tmpl := template.Must(template.New("checks").Parse(checksTemplate))

	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer func() {
		_ = f.Close()
	}()

	data := struct {
		Checks []checkDiscovery
	}{
		Checks: checks,
	}

	return tmpl.Execute(f, data)
}

const checksTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file is automatically generated from checks in checks/

package pgdoctor

import (
	"github.com/fresha/pgdoctor/check"
{{- range .Checks }}
	"{{ .ImportPath }}"
{{- end }}
	"github.com/fresha/pgdoctor/db"
)

// AllChecks returns all available check packages.
// Consumers call .Metadata() for check information or .New(conn) to instantiate checkers.
func AllChecks() []check.CheckPackage {
	return []check.CheckPackage{
{{- range .Checks }}
		{
			Metadata: {{ .PackageName }}.Metadata,
			New: func(conn db.DBTX) check.Checker {
				return {{ .PackageName }}.New(db.New(conn))
			},
		},
{{- end }}
	}
}
`
