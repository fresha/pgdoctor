# UUID Default Value Analysis

Detects UUID columns that use `gen_random_uuid()` (UUIDv4/random) as their DEFAULT value. Random UUIDs cause B-tree index fragmentation and bloat due to random insertion patterns.

## Why This Matters

**B-tree Index Behavior:**
- B-tree indexes maintain sorted order
- New values are inserted at their sorted position
- Random UUIDs insert at random positions throughout the index

**The Problem with Random UUIDs (v4):**
```
UUIDv4: 550e8400-e29b-41d4-a716-446655440000 (random)
        f47ac10b-58cc-4372-a567-0e02b2c3d479 (random)
        6ba7b810-9dad-11d1-80b4-00c04fd430c8 (random)

Insert order vs sorted position:
  Insert 1 → Page 47     (random position)
  Insert 2 → Page 12     (random position)
  Insert 3 → Page 89     (random position)
```

**Consequences:**
- **Page splits**: Every insert may split a different page
- **Index bloat**: 10-30% larger indexes over time
- **Buffer churn**: Many different pages in memory
- **Slower writes**: More I/O per insert
- **Worse cache hit ratio**: Random access patterns

**Time-Ordered UUIDs (v7) Solve This:**
```
UUIDv7: 018f8a1c-2345-7abc-8def-0123456789ab (2024-01-01 10:00:00)
        018f8a1c-2346-7abc-8def-0123456789ab (2024-01-01 10:00:01)
        018f8a1c-2347-7abc-8def-0123456789ab (2024-01-01 10:00:02)

Insert order matches sorted position:
  Insert 1 → End of index
  Insert 2 → End of index
  Insert 3 → End of index
```

This is identical to `bigint GENERATED BY DEFAULT AS IDENTITY` behavior - sequential inserts at the end.

## UUID Version Comparison

| Version | Pattern | Index Behavior | Use Case |
|---------|---------|----------------|----------|
| UUIDv1 | Time + MAC | Partially ordered | Legacy (avoid - MAC leaks) |
| UUIDv4 | Random | Scattered inserts | Client-generated IDs |
| UUIDv7 | Time-ordered | Sequential inserts | Primary keys, indexes |

**Performance Impact (10M row table):**

| Metric | UUIDv4 | UUIDv7 | Improvement |
|--------|--------|--------|-------------|
| Index size | 400MB | 300MB | 25% smaller |
| Insert rate | 50K/sec | 70K/sec | 40% faster |
| Buffer hit ratio | 85% | 98% | Better caching |
| Page splits/insert | ~0.3 | ~0.01 | 30x fewer |

## How to Fix

### For `random-uuid-indexed`

Change UUID default from random (v4) to time-ordered (v7) to reduce index bloat:

```sql
-- PostgreSQL 17+: Use native uuidv7()
ALTER TABLE events
  ALTER COLUMN id SET DEFAULT uuidv7();

-- PostgreSQL <17: Use pg_uuidv7 extension
CREATE EXTENSION IF NOT EXISTS pg_uuidv7;
ALTER TABLE events
  ALTER COLUMN id SET DEFAULT uuid_generate_v7();
```

**Note:** This only affects new rows. Existing rows keep their random UUIDs.

**Optional: Rebuild index to reclaim existing bloat**

```sql
-- Option A: REINDEX (locks table)
REINDEX INDEX CONCURRENTLY schema.table_name_pkey;

-- Option B: Create new index, swap (zero downtime)
CREATE INDEX CONCURRENTLY new_idx ON schema.table_name (id);
-- Then drop old index and rename new one
```

**Application code changes (if app generates UUIDs):**

```python
# Before: Random UUID
import uuid
record_id = uuid.uuid4()

# After: UUIDv7 (Python 3.12+ or uuid7 package)
import uuid
record_id = uuid.uuid7()  # Python 3.12+
```

```javascript
// Before: Random UUID
const id = crypto.randomUUID();

// After: UUIDv7 (use uuid package v9+)
import { v7 as uuidv7 } from 'uuid';
const id = uuidv7();
```

## Subchecks

### For `random-uuid-indexed`

Identifies UUID columns with the following conditions:
1. Column has an index (primary key or regular index)
2. Column has a DEFAULT using `gen_random_uuid()` or `uuid_generate_v4()`
3. Table has more than 100K rows (smaller tables have negligible impact)

**Severity:** WARN - Not urgent, but should be addressed during next schema update.

## Detection Criteria

This check identifies UUID columns where:
1. Column has a DEFAULT expression
2. DEFAULT uses `gen_random_uuid()` or `uuid_generate_v4()`
3. Column is indexed (PK or regular index)
4. Table has more than 100K rows (smaller tables are negligible)

**Why the 100K row threshold:**
- Index bloat is proportional to table size
- Small tables don't have measurable impact
- Focus on tables where the problem matters

## Severity Levels

- **WARN**: Indexed UUID column using random v4 default on table with >100K rows
  - Impact is real but not urgent
  - Monitor index bloat
  - Plan migration during next schema update

## Migration Guide

### For New Tables (Prevention)

Always use time-ordered UUIDs for indexed columns:

```sql
-- PostgreSQL 17+: Native uuidv7()
CREATE TABLE events (
  id uuid DEFAULT uuidv7() PRIMARY KEY,
  created_at timestamptz DEFAULT now()
);

-- PostgreSQL <17: Use pg_uuidv7 extension
CREATE EXTENSION IF NOT EXISTS pg_uuidv7;
CREATE TABLE events (
  id uuid DEFAULT uuid_generate_v7() PRIMARY KEY,
  created_at timestamptz DEFAULT now()
);

-- Alternative: bigint IDENTITY (simplest, best performance)
CREATE TABLE events (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz DEFAULT now()
);
```

### For Existing Tables (Migration)

Changing the DEFAULT only affects new rows - existing data is unchanged.

#### Step 1: Update the DEFAULT

```sql
-- PostgreSQL 17+
ALTER TABLE schema.table_name
  ALTER COLUMN id SET DEFAULT uuidv7();

-- PostgreSQL <17 with pg_uuidv7
ALTER TABLE schema.table_name
  ALTER COLUMN id SET DEFAULT uuid_generate_v7();
```

#### Step 2: Rebuild Index (Optional - Reclaim Bloat)

If you want to reclaim existing bloat:

```sql
-- Option A: REINDEX (locks table)
REINDEX INDEX CONCURRENTLY schema.table_name_pkey;

-- Option B: Create new index, swap (zero downtime)
CREATE INDEX CONCURRENTLY new_idx ON schema.table_name (id);
-- Then drop old index and rename new one
```

### Application Code Changes

If application generates UUIDs before insert:

```python
# Before: Random UUID
import uuid
record_id = uuid.uuid4()

# After: UUIDv7 (Python 3.12+ or uuid7 package)
import uuid
record_id = uuid.uuid7()  # Python 3.12+

# Or use uuid7 package for older Python
from uuid_extensions import uuid7
record_id = uuid7()
```

```javascript
// Before: Random UUID
const id = crypto.randomUUID();

// After: UUIDv7 (use uuid package v9+)
import { v7 as uuidv7 } from 'uuid';
const id = uuidv7();
```

## Monitoring Index Bloat

Check current index bloat:

```sql
-- Basic size check
SELECT
  indexrelname,
  pg_size_pretty(pg_relation_size(indexrelid)) AS size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

-- Detailed bloat analysis (requires pgstattuple)
CREATE EXTENSION IF NOT EXISTS pgstattuple;

SELECT
  indexrelname,
  pg_size_pretty(pg_relation_size(indexrelid)) AS size,
  round(100 * avg_leaf_density) || '%' AS density
FROM pg_stat_user_indexes
CROSS JOIN LATERAL pgstattuple(indexrelid)
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
```

**Healthy index density:** 80-90%
**Bloated index density:** <70%

## When to Accept Random UUIDs

Random UUIDs (v4) are acceptable when:
- **Client-generated IDs**: Offline/distributed clients generate IDs
- **Security requirement**: Unpredictable IDs needed
- **Small tables**: <100K rows (bloat is negligible)
- **Write-light tables**: Infrequent inserts

In these cases, monitor index bloat and rebuild periodically:

```sql
-- Schedule periodic reindex (e.g., weekly maintenance window)
REINDEX INDEX CONCURRENTLY schema.table_pkey;
```

## Related Checks

- **`uuid-types`**: Validates UUID columns use native uuid type (not varchar)
- **`pk-types`**: Validates primary keys won't overflow
- **`sequence-health`**: Monitors sequence capacity

## Common Questions

**Q: Will changing DEFAULT affect existing rows?**
A: No. DEFAULT only applies to new INSERTs where no value is provided.

**Q: Can I have both v4 and v7 UUIDs in the same column?**
A: Yes. All UUID versions are the same data type. The column will contain a mix of random (old) and time-ordered (new) values. Over time, the index will become more sequential as old rows are deleted.

**Q: Is UUIDv7 supported in my PostgreSQL version?**
A: Native `uuidv7()` function is PostgreSQL 17+ only. For earlier versions, use the `pg_uuidv7` extension or generate UUIDs in your application.

**Q: What about UUID as foreign keys?**
A: Changing the DEFAULT on a parent table has no effect on foreign keys. FK columns typically don't have defaults (they reference existing rows).

**Q: How much will this improve performance?**
A: Depends on write volume:
- Low write volume (<1K inserts/hour): Minimal impact
- Medium write volume (1K-100K/hour): 10-20% improvement
- High write volume (>100K/hour): 20-40% improvement in insert rate
